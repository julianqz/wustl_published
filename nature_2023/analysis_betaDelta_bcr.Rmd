---
title: "Alsoussi & Malladi et al., *Nature*, 2023 (repertoire; beta & delta-boosted)"
output: html_notebook
---

Author: Julian Q. Zhou

Docker container: `julianqz/wu_pub:r_4.1.0`

Visualizations are outputted as pdfs or pngs.

# Load packages & helper functions

```{r}
# modify the next line to set working directory accordingly
# setwd("[insert_your_working_directory_here]")

# summarize_clone
source("./c2b2/bcr_clone_info.R")

# circos_clonal_overlap
source("./c2b2/bcr_clonal_overlap_circos.R")

# prep_for_alluv, prep_for_paired_mf, get_stat_paired_mf
source("./c2b2/bcr_alluvial.R")

# vioplotLst
source("./c2b2/vis_vioplot.R")
```

```{r}
library(tibble)
library(ggplot2)
```

```{r}
versions::installed.versions(c("ggplot2", "circlize", "vioplot"))
```


# Setup

```{r}
### filenames
fn_db_bd = "WU382_alsoussi_et_al_nature_2023_betaDelta_bcr_heavy.tsv.gz"
fn_umap = "WU382_alsoussi_et_al_nature_2023_betaDelta_gex_b_cell_umap.tsv.gz"

### column names

col_comp = "compartment"
col_tp = "timepoint"

# [compartment]_[timepoint]
col_comp_tp = "compartment_timepoint"
# variant of the above
col_comp_tp_var = "compartment_timepoint_var"

# B cell clonal lineage ID
col_clone_id = "clone_id"
# TRUE if a clonal member of a S+ heavy chain-based B cell clone
col_s_pos_clone = "s_pos_clone"

# TRUE if MBC from blood
col_mem = "bloodMemory"

# transcriptomics-based cluster annotation
col_anno = "anno_leiden_0.35"

# replacement and silent mutation frequency
col_mf = "nuc_RS_freq_19_312"

# b0 = pre-3rd dose ("pre-boost"); b1 = post-3rd dose ("post-boost")
col_boo_num = "booster_num"
# regular = mRNA-1273; beta_delta = mRNA-1273.213
col_boo_type = "booster_type"

col_tissue = "tissue"
col_seq_id = "sequence_id"
col_donor = "donor"
col_sample = "sample"

### participants
DONORS = paste0("382-", c("01","02","07","08","13","15"))
```


# Load BCR data

```{r}
# db_all contains heavy chains from all clones regardless of S specificity
db_all_zz = gzfile(fn_db_bd,'rt')
db_all = read.table(db_all_zz, header=T, sep="\t", stringsAsFactors=F)
close(db_all_zz)

# Subset to S+ clones
db = db_all[db_all[[col_s_pos_clone]], ]
rm(db_all)
```

```{r}
# Recalculate SHM frequency to avoid numerical problems affecting $nuc_RS_freq_19_312
# that arise from writing and reading tsv's

# E.g. a "0.013108614" could become "0.013108615" after being exported and read back in

# Doing so ensures that the exact p-values reported in the paper can be reproduced
db[[col_mf]] = db[["nuc_RS_19_312"]] / db[["nuc_denom_19_312"]]
```

```{r}
# Restrict memory compartment analysis to MBC from blood (as opposed to LN)

db[[col_mem]] = FALSE
bool_mem = which(db[[col_comp]]=="MBC" & db[[col_tissue]]=="blood")
db[[col_mem]][bool_mem] = TRUE
```

```{r}
# Create a [compartment]_[timepoint] column
db[[col_comp_tp]] = paste0(db[[col_comp]], "_", db[[col_tp]])

# Create a variant of the [compartment]_[timepoint] column which would allow
# convenient subsetting to the sequences to be used for memory compartment analysis
# via `bloodMemory`
db[[col_comp_tp_var]] = db[[col_comp_tp]]
db[[col_comp_tp_var]][db[[col_mem]]] = paste0(col_mem, "_",
                                              db[[col_tp]][db[[col_mem]]])
```

```{r}
# booster type
# `regular` = mRNA-1273; `beta_delta` = mRNA-1273.213
df_donor_boo_type = unique(db[db[[col_boo_num]]!="b0", c(col_donor, col_boo_type)])
vec_donor_boo_type = df_donor_boo_type[[col_boo_type]]
names(vec_donor_boo_type) = df_donor_boo_type[[col_donor]]

donor_levels = paste0("382-", c("02","07","08",  # regular
                                "01","13","15")) # beta/delta
boo_type_levels = c("regular", "beta_delta")
```

# Clone-level summary

First, we create a `data.frame` in which each row represents a clone, and columns
tabulate the number of sequences in a compartment and in a compartment-timepoint
combination.

```{r}
clone_info = summarize_clone(db=db, col_clone=col_clone_id, 
                             col_vec=c(col_comp, col_comp_tp_var),
                             order_by_size="none")

# Extract participant ID from clone ID, which has the format [donor]@[clone]
clone_info[[col_donor]] = sapply(clone_info[[col_clone_id]],
                                 function(s){strsplit(s, "@")[[1]][1]})
```


# Circos plots for clonal overlap

* Fig 2c
* Extended Data Fig 3ij

`circos_clonal_overlap` produces a circos plot, and prints out (i) the number and
percentage of clones with clonal overlap, and (ii) the number of sequences.

Starting with the arc at the 12 o'clock position and going clockwise, the identities of 
the arcs correspond to the rows in the printed table from top to bottom.

### How to read the circos plots

* An arc represents BCR sequences from a B cell compartment or 
compartment-timepoint combination
* The length of an arc corresponds to the number of BCR sequences 
represented by the arc
* Chords connect clonally related sequences
* The width of a chord corresponds to the size of the clone represented 
by the chord
* Chords are coloured based on whether there's "overlap"
* Overlap can be defined as overlap between compartments, between 
compartment-timepoint combinations, etc.

### Fig 2c - clonal overlap between post-boost week 1 PB and pre-boost

```{r}
### prep

# pre-boost timepoints
vec_s_pos_b0_tp = c(paste0("b0_d", c(28,35,60,110,201)), "b0_m6or9")

# all possible pre-boost compartiment-timepoint combinations
vec_s_pos_b0_comp_tp = c(paste0("PB_", vec_s_pos_b0_tp),
                           paste0("Naive_", vec_s_pos_b0_tp),
                           paste0("ABC_", vec_s_pos_b0_tp),
                           paste0("GC_", vec_s_pos_b0_tp),
                           paste0("LNPC_", vec_s_pos_b0_tp),
                           paste0("bloodMemory_", vec_s_pos_b0_tp),
                           paste0("MBC_", vec_s_pos_b0_tp),
                           paste0("BMPC_", vec_s_pos_b0_tp))

# pre-boost compartiment-timepoint combinations that don't exist
bool_s_pos_b0_comp_tp_a = vec_s_pos_b0_comp_tp %in% unique(db[[col_comp_tp_var]][db[[col_boo_num]]=="b0"])
cat("Excluded due to non-existence in data:", 
    vec_s_pos_b0_comp_tp[!bool_s_pos_b0_comp_tp_a], "\n")

# pre-boost sequences with NA compartment (excluded)
bool_s_pos_b0_comp_tp_b = unique(db[[col_comp_tp_var]][db[[col_boo_num]]=="b0"]) %in% vec_s_pos_b0_comp_tp
cat("Verify that these are intended to be excluded:", 
    sort(unique(db[[col_comp_tp_var]][db[[col_boo_num]]=="b0"])[!bool_s_pos_b0_comp_tp_b]), "\n")

# pre-boost compartment-timepoint combinations for visualization
vec_s_pos_b0_comp_tp = vec_s_pos_b0_comp_tp[bool_s_pos_b0_comp_tp_a]
stopifnot(all(vec_s_pos_b0_comp_tp %in% db[[col_comp_tp_var]][db[[col_boo_num]]=="b0"]))
```


```{r}
### visualization

# all compartment-timepoint combinations for visualization
vec_sectors_b1_pb_tp = c("PB_b1_d8", vec_s_pos_b0_comp_tp)

# arc representing all pre-boost (non-NA compartment) combined
sector_b0_combined = "b0_combined"
# name of temporary column (to be created on the fly)
col_tmp_b0_combined = "tmp_comp"

# all arcs
vec_sectors_b1_pb_tp_b0_combined = c("PB_b1_d8", sector_b0_combined)
# definition of each arc
vec_sectors_type_b1_pb_tp_b0_combined = c("PB_b1_d8", sector_b0_combined)
# compartment of each arc
vec_sectors_comp_b1_pb_tp_b0_combined = c("PB", "combined")
# colour of each arc
vec_sectors_color_uniq_b1_pb_tp_b0_combined = c("PB"="firebrick2",
                                                "combined"="khaki3")
stopifnot(all(unique(vec_sectors_comp_b1_pb_tp_b0_combined) %in% names(vec_sectors_color_uniq_b1_pb_tp_b0_combined)))
vec_sectors_color_b1_pb_tp_b0_combined = vec_sectors_color_uniq_b1_pb_tp_b0_combined[vec_sectors_comp_b1_pb_tp_b0_combined]

# width of gaps between arcs
vec_gaps_b1_pb_tp_b0_combined = rep(7, length(vec_sectors_b1_pb_tp_b0_combined))
# column in sequence data.frame that contains arc labels
col_sector_b1_pb_tp_b0_combined = col_tmp_b0_combined

# definition of overlap (i.e. between post-boost wk 1 PB and pre-boost)
vec_overlap_types_b1_pb_tp_b0_combined = c("PB_b1_d8", sector_b0_combined)
# colour of chord when there's overlap 
color_overlap_b1_pb_tp_b0_combined = "purple"
# colour of chord when there's no overlap 
color_no_overlap_b1_pb_tp_b0_combined = "gray40"

fn_sink = "fig_2c_info.txt"
sink(fn_sink)

for (d in DONORS) {
    cat("\n", d, "\n")
    # subset to current donor
    d_db = db[db[[col_donor]]==d, ]
    d_clone_info = clone_info[clone_info[[col_clone_id]] %in% d_db[[col_clone_id]], ]
    
    # create temp column on the fly
    d_db[[col_tmp_b0_combined]] = d_db[[col_comp_tp_var]]
    d_db[[col_tmp_b0_combined]][ d_db[[col_tmp_b0_combined]] %in% vec_sectors_b1_pb_tp &
                                 d_db[[col_tmp_b0_combined]]!="PB_b1_d8" ] = sector_b0_combined
    
    # re-calculate for d_clone_info
    # count number of seqs in b0_combined 
    # (i.e. all sectors in vec_sectors_b1_pb_tp except for PB_b1_d8)
    stopifnot(all(vec_sectors_b1_pb_tp %in% colnames(d_clone_info)))
    d_clone_info[[sector_b0_combined]] = rowSums(d_clone_info[, vec_sectors_b1_pb_tp[-which(vec_sectors_b1_pb_tp=="PB_b1_d8")]])
    
    # vis
    d_fn = paste0("fig_2c_", d, ".pdf")
    pdf(d_fn, width=5, height=5)
    
    circos_clonal_overlap(vec_sectors=vec_sectors_b1_pb_tp_b0_combined, 
                          vec_sectors_type=vec_sectors_type_b1_pb_tp_b0_combined, 
                          vec_sectors_color=vec_sectors_color_b1_pb_tp_b0_combined, 
                          vec_gaps=vec_gaps_b1_pb_tp_b0_combined,  
                          vec_overlap_types=vec_overlap_types_b1_pb_tp_b0_combined,
                          col_sector=col_sector_b1_pb_tp_b0_combined, 
                          col_clone_id=col_clone_id, 
                          df_seq_data=d_db, 
                          df_clone_info=d_clone_info, 
                          color_overlap=color_overlap_b1_pb_tp_b0_combined, 
                          color_no_overlap=color_no_overlap_b1_pb_tp_b0_combined)
    
    dev.off()
}

sink()
```


### Extended Data Fig 3ij - clonal overlap between post-boost PB and GC

The percentages plotted in Extended Data Fig 3j were extracted from `ed_fig_3i_info.txt` produced below.

```{r}
# all arcs
vec_sectors_b1_pb_gc_tp = c("PB_b1_d8","GC_b1_d15","GC_b1_d57")
# definition of each arc
vec_sectors_type_b1_pb_gc_tp = c("PB_b1_d8", "GC_b1", "GC_b1")
# colour of each arc
vec_sectors_color_b1_pb_gc_tp = c("firebrick2", "dodgerblue2", "dodgerblue2")

# width of gaps between arcs
vec_gaps_b1_pb_gc_tp = rep(4, length(vec_sectors_b1_pb_gc_tp))
# column in sequence data.frame that contains arc labels
col_sector_b1_pb_gc_tp = col_comp_tp_var

# definition of overlap (i.e. between post-boost wk1 PB and post-boost GC)
vec_overlap_types_b1_pb_gc_tp = c("PB_b1_d8", "GC_b1")
# colour of chord when there's overlap
color_overlap_b1_pb_gc_tp = "purple"
# colour of chord when there's no overlap
color_no_overlap_b1_pb_gc_tp = "gray40"

fn_sink = "ed_fig_3i_info.txt"
sink(fn_sink)

for (d in DONORS) {
    cat("\n", d, "\n")
    # subset to current donor
    d_db = db[db[[col_donor]]==d, ]
    d_clone_info = clone_info[clone_info[[col_clone_id]] %in% d_db[[col_clone_id]], ]
    
    # $GC_b1 does not yet exist in d_clone_indo and needs to be created
    d_clone_info[["GC_b1"]] = rowSums(d_clone_info[, c("GC_b1_d15","GC_b1_d57")])
    
    d_fn = paste0("ed_fig_3i_", d, ".pdf")
    pdf(d_fn, width=5, height=5)
    
    circos_clonal_overlap(vec_sectors=vec_sectors_b1_pb_gc_tp, 
                          vec_sectors_type=vec_sectors_type_b1_pb_gc_tp, 
                          vec_sectors_color=vec_sectors_color_b1_pb_gc_tp, 
                          vec_gaps=vec_gaps_b1_pb_gc_tp,  
                          vec_overlap_types=vec_overlap_types_b1_pb_gc_tp,
                          col_sector=col_sector_b1_pb_gc_tp, 
                          col_clone_id=col_clone_id, 
                          df_seq_data=d_db, 
                          df_clone_info=d_clone_info, 
                          color_overlap=color_overlap_b1_pb_gc_tp, 
                          color_no_overlap=color_no_overlap_b1_pb_gc_tp)
    
    dev.off()
}

sink()
```


# Clone-wise pre- vs. post-boost SHM frequency comparisons

* Fig 2d (PB)
* Fig 2f (MBC)
* Fig 2g (BMPC)

*The code-generated plots from below were prototypes based on which the published 
versions were generated using GraphPad Prism v9.*


### How to read the clone-wise SHM frequency plots

* Each line corresponds to a B cell clone
* Each end of the line corresponds to the median SHM frequency of the clonal 
members in a given compartment or compartment-timepoint combination

### Preparation

#### Fig 2d - pre-boost PB vs. post-boost PB

```{r}
# all compartment-timepoint combinations to consider
alluv_cols_pb_tp = c("PB_b0_d28", "PB_b1_d8")

# regex to extract what labels define overlap
vec_overlap_regex_pb_tp = c("PB_b0_", "PB_b1_")

# `prep_for_alluv` returns `alluv_df` and `alluv_lst_cl_id` (explained below)
alluv_prep_pb_tp = prep_for_alluv(alluv_cols=alluv_cols_pb_tp, 
                                   df_clone_info=clone_info,
                                   col_df_clone_id=col_clone_id,
                                   vec_overlap_regex=vec_overlap_regex_pb_tp)

# `alluv_df` 
# (i) exhaustively lists all binary combinations of all compartment-timepoint's
# (ii) counts the number of clones belonging to each binary combination
# (iii) determines whether each binary combination constitutes an overlap

# E.g.:
#   PB_b0_d28 PB_b1_d8 count overlap
# 1      TRUE     TRUE   156    TRUE
# 2     FALSE     TRUE   118   FALSE
# 3      TRUE    FALSE   200   FALSE
# 4     FALSE    FALSE  1011   FALSE
alluv_df_pb_tp = alluv_prep_pb_tp[["alluv_df"]]

# `alluv_lst_cl_id`
# For each binary combination (row) in `alluv_df`,
# record the clone IDs of the clones belonging to that binary combination
alluv_lst_cl_id_pb_tp = alluv_prep_pb_tp[["alluv_lst_cl_id"]]

# compartment-timepoint's to visualize
lst_pairs_pb_tp = list(c("PB_b0_d28", "PB_b1_d8"))

# `prep_for_paired_mf` returns `vec_facets`, `pairs_df_wide/long` (explained below)
prep_pairs_pb_tp = prep_for_paired_mf(lst_pairs=lst_pairs_pb_tp, 
                                      alluv_cols=alluv_cols_pb_tp, 
                                      alluv_df=alluv_df_pb_tp, 
                                      alluv_lst_cl_id=alluv_lst_cl_id_pb_tp,
                                      df_data=db, 
                                      col_df_clone_id=col_clone_id, 
                                      col_df_mf=col_mf, 
                                      col_df_label=col_comp_tp_var)

# A wide-format data.frame
# Each row corresponds to a clone
# `a_ident` and `b_ident` specifies the compartment-timepoint's of interest
# `a_val` and `b_val` records the clonal median SHM frequency of `a_ident` and `b_ident` resp.

# E.g.:
#                   facet        clone_id   a_ident  b_ident       a_val      b_val
# 1   PB_b0_d28 + PB_b1_d8  382-01@G1292_1 PB_b0_d28 PB_b1_d8 0.029629630 0.05185185
# 2   PB_b0_d28 + PB_b1_d8  382-01@G1483_1 PB_b0_d28 PB_b1_d8 0.000000000 0.04074074
pairs_df_wide_pb_tp = prep_pairs_pb_tp[["pairs_df_wide"]]

# The same data.frame in long-format; used by ggplot2
pairs_df_long_pb_tp = prep_pairs_pb_tp[["pairs_df_long"]]

# create an artificial ident_2 column to simplify compartment-timepoint labels
pairs_df_long_pb_tp[["ident_2"]] = c("PB_b0_d28"="Pre-boost", 
                                     "PB_b1_d8"="Post-boost")[pairs_df_long_pb_tp[["ident"]]]

pairs_df_long_pb_tp[["ident_2"]] = factor(pairs_df_long_pb_tp[["ident_2"]], 
                                          levels=c("Pre-boost", "Post-boost")
)

# create an artificial dummy column to control line colour
pairs_df_long_pb_tp[["hack"]] = factor("dummy")

# extract participant ID based on clone ID
pairs_df_long_pb_tp[[col_donor]] = sapply(pairs_df_long_pb_tp[[col_clone_id]], 
                                          function(s){strsplit(s, "@")[[1]][1]})
pairs_df_long_pb_tp[[col_donor]] = factor(pairs_df_long_pb_tp[[col_donor]],
                                          levels=donor_levels)

pairs_df_wide_pb_tp[[col_donor]] = sapply(pairs_df_wide_pb_tp[[col_clone_id]], 
                                          function(s){strsplit(s, "@")[[1]][1]})
pairs_df_wide_pb_tp[[col_donor]] = factor(pairs_df_wide_pb_tp[[col_donor]],
                                          levels=donor_levels)

# add booster type (to be used for faceting)
pairs_df_long_pb_tp[[col_boo_type]] = vec_donor_boo_type[as.character(pairs_df_long_pb_tp[[col_donor]])]
pairs_df_long_pb_tp[[col_boo_type]] = factor(pairs_df_long_pb_tp[[col_boo_type]],
                                             levels=boo_type_levels)

pairs_df_wide_pb_tp[[col_boo_type]] = vec_donor_boo_type[as.character(pairs_df_wide_pb_tp[[col_donor]])]
pairs_df_wide_pb_tp[[col_boo_type]] = factor(pairs_df_wide_pb_tp[[col_boo_type]],
                                             levels=boo_type_levels)
```


#### Fig 2f - pre-boost MBC vs. post-boost MBC

```{r}
# all compartment-timepoint combinations to consider
alluv_cols_mbc_tp = c("bloodMemory_b0_d201", "bloodMemory_b1_d121")

# regex to extract what labels define overlap
vec_overlap_regex_mbc_tp = c("bloodMemory_b0_d201", "bloodMemory_b1_d121")

# prep_for_alluv returns `alluv_df` and `alluv_lst_cl_id` (explained below)
alluv_prep_mbc_tp = prep_for_alluv(alluv_cols=alluv_cols_mbc_tp, 
                                  df_clone_info=clone_info,
                                  col_df_clone_id=col_clone_id,
                                  vec_overlap_regex=vec_overlap_regex_mbc_tp)


# `alluv_df` 
# (i) exhaustively lists all binary combinations of all compartment-timepoint's
# (ii) counts the number of clones belonging to each binary combination
# (iii) determines whether each binary combination constitutes an overlap

# E.g.:
#   bloodMemory_b0_d201 bloodMemory_b1_d121 count overlap
# 1                TRUE                TRUE    81    TRUE
# 2               FALSE                TRUE   387   FALSE
# 3                TRUE               FALSE   113   FALSE
# 4               FALSE               FALSE   904   FALSE
alluv_df_mbc_tp = alluv_prep_mbc_tp[["alluv_df"]]


# `alluv_lst_cl_id`
# For each binary combination (row) in `alluv_df`,
# record the clone IDs of the clones belonging to that binary combination
alluv_lst_cl_id_mbc_tp = alluv_prep_mbc_tp[["alluv_lst_cl_id"]]

# compartment-timepoint's to visualize
lst_pairs_mbc_tp = list(c("bloodMemory_b0_d201", "bloodMemory_b1_d121"))

# `prep_for_paired_mf` returns `vec_facets`, `pairs_df_wide/long` (explained below)
prep_pairs_mbc_tp = prep_for_paired_mf(lst_pairs=lst_pairs_mbc_tp, 
                                      alluv_cols=alluv_cols_mbc_tp, 
                                      alluv_df=alluv_df_mbc_tp, 
                                      alluv_lst_cl_id=alluv_lst_cl_id_mbc_tp,
                                      df_data=db, 
                                      col_df_clone_id=col_clone_id, 
                                      col_df_mf=col_mf, 
                                      col_df_label=col_comp_tp_var)

# A wide-format data.frame
# Each row corresponds to a clone
# `a_ident` and `b_ident` specifies the compartment-timepoint's of interest
# `a_val` and `b_val` records the clonal median SHM frequency of `a_ident` and `b_ident` resp.

# E.g.:
#                                        facet        clone_id             a_ident             b_ident      a_val      b_val
# 1  bloodMemory_b0_d201 + bloodMemory_b1_d121  382-01@G1292_1 bloodMemory_b0_d201 bloodMemory_b1_d121 0.04259259 0.06111111
# 2  bloodMemory_b0_d201 + bloodMemory_b1_d121  382-01@G2148_1 bloodMemory_b0_d201 bloodMemory_b1_d121 0.06367041 0.04494382
pairs_df_wide_mbc_tp = prep_pairs_mbc_tp[["pairs_df_wide"]]

# The same data.frame in long-format; used by ggplot2
pairs_df_long_mbc_tp = prep_pairs_mbc_tp[["pairs_df_long"]]


# create an artificial ident_2 column to simplify compartment-timepoint labels
# to just timepoint (since both are PB)

pairs_df_long_mbc_tp[["ident_2"]] = c("bloodMemory_b0_d201"="Pre-boost", 
                                      "bloodMemory_b1_d121"="Post-boost")[pairs_df_long_mbc_tp[["ident"]]]

pairs_df_long_mbc_tp[["ident_2"]] = factor(pairs_df_long_mbc_tp[["ident_2"]], 
                                           levels=c("Pre-boost", "Post-boost")
)

# create an artificial dummy column to control line colour
pairs_df_long_mbc_tp[["hack"]] = factor("dummy")

# extract participant ID based on clone ID
pairs_df_long_mbc_tp[[col_donor]] = sapply(pairs_df_long_mbc_tp[[col_clone_id]], 
                                          function(s){strsplit(s, "@")[[1]][1]})
pairs_df_long_mbc_tp[[col_donor]] = factor(pairs_df_long_mbc_tp[[col_donor]],
                                          levels=donor_levels)

pairs_df_wide_mbc_tp[[col_donor]] = sapply(pairs_df_wide_mbc_tp[[col_clone_id]], 
                                            function(s){strsplit(s, "@")[[1]][1]})
pairs_df_wide_mbc_tp[[col_donor]] = factor(pairs_df_wide_mbc_tp[[col_donor]],
                                            levels=donor_levels)

# add booster type (to be used for faceting)
pairs_df_long_mbc_tp[[col_boo_type]] = vec_donor_boo_type[as.character(pairs_df_long_mbc_tp[[col_donor]])]
pairs_df_long_mbc_tp[[col_boo_type]] = factor(pairs_df_long_mbc_tp[[col_boo_type]],
                                               levels=boo_type_levels)

pairs_df_wide_mbc_tp[[col_boo_type]] = vec_donor_boo_type[as.character(pairs_df_wide_mbc_tp[[col_donor]])]
pairs_df_wide_mbc_tp[[col_boo_type]] = factor(pairs_df_wide_mbc_tp[[col_boo_type]],
                                               levels=boo_type_levels)
```


#### Fig 2g - pre-boost BMPC vs. post-boost BMPC

```{r}
# all compartment-timepoint combinations to consider
alluv_cols_bmpc_tp = c("BMPC_b0_m6or9", "BMPC_b1_d181")

# regex to extract what labels define overlap
vec_overlap_regex_bmpc_tp = c("BMPC_b0_m6or9", "BMPC_b1_d181")

# prep_for_alluv returns `alluv_df` and `alluv_lst_cl_id` (explained below)
alluv_prep_bmpc_tp = prep_for_alluv(alluv_cols=alluv_cols_bmpc_tp, 
                                  df_clone_info=clone_info,
                                  col_df_clone_id=col_clone_id,
                                  vec_overlap_regex=vec_overlap_regex_bmpc_tp)


# `alluv_df` 
# (i) exhaustively lists all binary combinations of all compartment-timepoint's
# (ii) counts the number of clones belonging to each binary combination
# (iii) determines whether each binary combination constitutes an overlap

# E.g.:
#   BMPC_b0_m6or9 BMPC_b1_d181 count overlap
# 1          TRUE         TRUE    22    TRUE
# 2         FALSE         TRUE   135   FALSE
# 3          TRUE        FALSE    19   FALSE
# 4         FALSE        FALSE  1309   FALSE
alluv_df_bmpc_tp = alluv_prep_bmpc_tp[["alluv_df"]]


# `alluv_lst_cl_id`
# For each binary combination (row) in `alluv_df`,
# record the clone IDs of the clones belonging to that binary combination
alluv_lst_cl_id_bmpc_tp = alluv_prep_bmpc_tp[["alluv_lst_cl_id"]]

# compartment-timepoint's to visualize
lst_pairs_bmpc_tp = list(c("BMPC_b0_m6or9", "BMPC_b1_d181"))

# `prep_for_paired_mf` returns `vec_facets`, `pairs_df_wide/long` (explained below)
prep_pairs_bmpc_tp = prep_for_paired_mf(lst_pairs=lst_pairs_bmpc_tp, 
                                      alluv_cols=alluv_cols_bmpc_tp, 
                                      alluv_df=alluv_df_bmpc_tp, 
                                      alluv_lst_cl_id=alluv_lst_cl_id_bmpc_tp,
                                      df_data=db, 
                                      col_df_clone_id=col_clone_id, 
                                      col_df_mf=col_mf, 
                                      col_df_label=col_comp_tp_var)

# A wide-format data.frame
# Each row corresponds to a clone
# `a_ident` and `b_ident` specifies the compartment-timepoint's of interest
# `a_val` and `b_val` records the clonal median SHM frequency of `a_ident` and `b_ident` resp.

# E.g.:
#                            facet        clone_id a_ident              b_ident      a_val      b_val
# 1 BMPC_b0_m6or9 + BMPC_b1_d181 382-01@G2148_1 BMPC_b0_m6or9 BMPC_b1_d181 0.02996255 0.05992509
# 2 BMPC_b0_m6or9 + BMPC_b1_d181 382-01@G3274_1 BMPC_b0_m6or9 BMPC_b1_d181 0.04868914 0.05992509
pairs_df_wide_bmpc_tp = prep_pairs_bmpc_tp[["pairs_df_wide"]]

# The same data.frame in long-format; used by ggplot2
pairs_df_long_bmpc_tp = prep_pairs_bmpc_tp[["pairs_df_long"]]


# create an artificial ident_2 column to simplify compartment-timepoint labels

pairs_df_long_bmpc_tp[["ident_2"]] = c("BMPC_b0_m6or9"="Pre-boost", 
                                       "BMPC_b1_d181"="Post-boost")[pairs_df_long_bmpc_tp[["ident"]]]

pairs_df_long_bmpc_tp[["ident_2"]] = factor(pairs_df_long_bmpc_tp[["ident_2"]], 
                                          levels=c("Pre-boost", "Post-boost")
)

# create an artificial dummy column to control line colour
pairs_df_long_bmpc_tp[["hack"]] = factor("dummy")

# extract participant ID based on clone ID
pairs_df_long_bmpc_tp[[col_donor]] = sapply(pairs_df_long_bmpc_tp[[col_clone_id]], 
                                          function(s){strsplit(s, "@")[[1]][1]})
pairs_df_long_bmpc_tp[[col_donor]] = factor(pairs_df_long_bmpc_tp[[col_donor]],
                                          levels=donor_levels)

pairs_df_wide_bmpc_tp[[col_donor]] = sapply(pairs_df_wide_bmpc_tp[[col_clone_id]], 
                                          function(s){strsplit(s, "@")[[1]][1]})
pairs_df_wide_bmpc_tp[[col_donor]] = factor(pairs_df_wide_bmpc_tp[[col_donor]],
                                          levels=donor_levels)

# add booster type (to be used for faceting)
pairs_df_long_bmpc_tp[[col_boo_type]] = vec_donor_boo_type[as.character(pairs_df_long_bmpc_tp[[col_donor]])]
pairs_df_long_bmpc_tp[[col_boo_type]] = factor(pairs_df_long_bmpc_tp[[col_boo_type]],
                                             levels=boo_type_levels)

pairs_df_wide_bmpc_tp[[col_boo_type]] = vec_donor_boo_type[as.character(pairs_df_wide_bmpc_tp[[col_donor]])]
pairs_df_wide_bmpc_tp[[col_boo_type]] = factor(pairs_df_wide_bmpc_tp[[col_boo_type]],
                                             levels=boo_type_levels)

```

### Visualization

```{r}
# common y-axis upper limit
ymax_common_gg = max(c(pairs_df_long_pb_tp[["val"]], 
                       pairs_df_long_mbc_tp[["val"]],
                       pairs_df_long_bmpc_tp[["val"]]))

# line color
col_line = scales::alpha("purple", 0.35)
```

#### Fig 2d - pre-boost PB vs. post-boost PB

```{r}
pairs_pb_tp_plot_by_boo_type = ggplot(pairs_df_long_pb_tp, 
                                   aes(x=ident_2, y=val, group=clone_id)) + 
    geom_line(aes(color=hack)) +
    ylim(0, ymax_common_gg*1.02) +
    geom_point(aes(color=ident_2))+
    scale_color_manual(values=c(
        "Pre-boost"="firebrick2", "Post-boost"="firebrick2", 
        "dummy"=col_line)) +
    facet_wrap(facets=vars(!!sym(col_boo_type)), nrow=1) +
    labs(y="IGHV nucleotide mutation frequency") +
    theme_bw() +
    theme(axis.title.x=element_blank()) +
    theme(axis.text.x=element_text(size=13)) +
    theme(axis.text.y=element_text(size=13)) +
    theme(axis.title=element_text(size=13)) +
    theme(strip.background=element_rect(fill="transparent"),
          strip.text.x=element_text(size=13)
    ) +
    theme(legend.position="none") +
    theme(panel.grid.major=element_blank())

fn = "fig_2d.pdf"
ggsave(filename=fn, plot=pairs_pb_tp_plot_by_boo_type, device="pdf", 
       width=8, height=4) 

# stats
# (i) print out, for each facet, 
#  - the number of clones
#  - the median SHM frequency of each compartment-timepoint
#    (a_val is always plotted on the left; b_val always on the right)
# (ii) perform two-sided, paired, Mann-Whitney tests
#  - correction for multiple testing by Benjamini & Hochberg

# stratify by booster type
# make a copy
pairs_df_wide_pb_tp_2 = pairs_df_wide_pb_tp
pairs_df_wide_pb_tp_2[["facet"]] = paste0(pairs_df_wide_pb_tp_2[["facet"]], "_",
                                          as.character(pairs_df_wide_pb_tp_2[[col_boo_type]]))
vec_facets_pb_tp_by_boo_type = unique(pairs_df_wide_pb_tp_2[["facet"]])

pairs_p_pb_tp_by_boo_type = get_stat_paired_mf(vec_facets=vec_facets_pb_tp_by_boo_type, 
                                               pairs_df_wide=pairs_df_wide_pb_tp_2, 
                                               p_adj_method="BH")

pairs_p_pb_tp_by_boo_type[["vec_p_unadj"]]
pairs_p_pb_tp_by_boo_type[["vec_p_adj"]]
```


#### Fig 2f - pre-boost MBC vs. post-boost MBC

```{r}
pairs_mbc_tp_plot_by_boo_type = ggplot(pairs_df_long_mbc_tp, 
                                        aes(x=ident_2, y=val, group=clone_id)) + 
    geom_line(aes(color=hack)) +
    ylim(0, ymax_common_gg*1.02) +
    geom_point(aes(color=ident_2))+
    scale_color_manual(values=c(
        "Pre-boost"="plum2", "Post-boost"="plum2", 
        "dummy"=col_line)) +
    facet_wrap(facets=vars(!!sym(col_boo_type)), nrow=1) +
    labs(y="IGHV nucleotide mutation frequency") +
    theme_bw() +
    theme(axis.title.x=element_blank()) +
    theme(axis.text.x=element_text(size=13)) +
    theme(axis.text.y=element_text(size=13)) +
    theme(axis.title=element_text(size=13)) +
    theme(strip.background=element_rect(fill="transparent"),
          strip.text.x=element_text(size=13)
    ) +
    theme(legend.position="none") +
    theme(panel.grid.major=element_blank())

fn = "fig_2f.pdf"
ggsave(filename=fn, plot=pairs_mbc_tp_plot_by_boo_type, device="pdf", 
       width=8, height=4) 


# stats
# (i) print out, for each facet, 
#  - the number of clones
#  - the median SHM frequency of each compartment-timepoint
#    (a_val is always plotted on the left; b_val always on the right)
# (ii) perform two-sided, paired, Mann-Whitney tests
#  - correction for multiple testing by Benjamini & Hochberg

# stratify by booster type
# make a copy
pairs_df_wide_mbc_tp_2 = pairs_df_wide_mbc_tp
pairs_df_wide_mbc_tp_2[["facet"]] = paste0(pairs_df_wide_mbc_tp_2[["facet"]], "_",
                                            as.character(pairs_df_wide_mbc_tp_2[[col_boo_type]]))
vec_facets_mbc_tp_by_boo_type = unique(pairs_df_wide_mbc_tp_2[["facet"]])

pairs_p_mbc_tp_by_boo_type = get_stat_paired_mf(vec_facets=vec_facets_mbc_tp_by_boo_type, 
                                                 pairs_df_wide=pairs_df_wide_mbc_tp_2, 
                                                 p_adj_method="BH")

pairs_p_mbc_tp_by_boo_type[["vec_p_unadj"]]
pairs_p_mbc_tp_by_boo_type[["vec_p_adj"]]
```

#### Fig 2g - pre-boost BMPC vs. post-boost BMPC

```{r}
pairs_bmpc_tp_plot_by_boo_type = ggplot(pairs_df_long_bmpc_tp, 
                                      aes(x=ident_2, y=val, group=clone_id)) + 
    geom_line(aes(color=hack)) +
    ylim(0, ymax_common_gg*1.02) +
    geom_point(aes(color=ident_2))+
    scale_color_manual(values=c(
        "Pre-boost"="black", "Post-boost"="black", 
        "dummy"=col_line)) +
    facet_wrap(facets=vars(!!sym(col_boo_type)), nrow=1) +
    labs(y="IGHV nucleotide mutation frequency") +
    theme_bw() +
    theme(axis.title.x=element_blank()) +
    theme(axis.text.x=element_text(size=13)) +
    theme(axis.text.y=element_text(size=13)) +
    theme(axis.title=element_text(size=13)) +
    theme(strip.background=element_rect(fill="transparent"),
          strip.text.x=element_text(size=13)
    ) +
    theme(legend.position="none") +
    theme(panel.grid.major=element_blank())

fn = "fig_2g.pdf"
ggsave(filename=fn, plot=pairs_bmpc_tp_plot_by_boo_type, device="pdf", 
       width=8, height=4) 


# stats
# (i) print out, for each facet, 
#  - the number of clones
#  - the median SHM frequency of each compartment-timepoint
#    (a_val is always plotted on the left; b_val always on the right)
# (ii) perform two-sided, paired, Mann-Whitney tests
#  - correction for multiple testing by Benjamini & Hochberg

# stratify by booster type
# make a copy
pairs_df_wide_bmpc_tp_2 = pairs_df_wide_bmpc_tp
pairs_df_wide_bmpc_tp_2[["facet"]] = paste0(pairs_df_wide_bmpc_tp_2[["facet"]], "_",
                                            as.character(pairs_df_wide_bmpc_tp_2[[col_boo_type]]))
vec_facets_bmpc_tp_by_boo_type = unique(pairs_df_wide_bmpc_tp_2[["facet"]])

pairs_p_bmpc_tp_by_boo_type = get_stat_paired_mf(vec_facets=vec_facets_bmpc_tp_by_boo_type, 
                                                 pairs_df_wide=pairs_df_wide_bmpc_tp_2, 
                                                 p_adj_method="BH")

pairs_p_bmpc_tp_by_boo_type[["vec_p_unadj"]]
pairs_p_bmpc_tp_by_boo_type[["vec_p_adj"]]
```


# UMAPs

#### Prep

```{r}
# UMAP coordinates
gex_umap_zz = gzfile(fn_umap,'rt')
gex_umap = read.table(gex_umap_zz, header=T, sep="\t", stringsAsFactors=F)
close(gex_umap_zz)

# match up cells in `db` with those in `gex_umap`
idx = match(db[["cell_id"]], gex_umap[["cell_id"]])

bool_idx_non_na = !is.na(idx)

# sanity check
stopifnot(all.equal( db[["cell_id"]][bool_idx_non_na],
                     gex_umap[["cell_id"]][ idx[bool_idx_non_na] ] ))

# create a column indicating whether a cell in `gex_umap` belonged to 
# a S+ B cell clone
gex_umap[[col_s_pos_clone]] = FALSE
gex_umap[[col_s_pos_clone]][ idx[bool_idx_non_na] ] = TRUE

# create a $timepoint column consistent with the format in `db`
gex_umap[[col_tp]] = paste0("b", gex_umap[[col_boo_num]], "_", gex_umap[[col_tp]])

gex_umap[[col_tp]] = factor(gex_umap[[col_tp]],
                            levels=c("b0_d201", "b1_d8","b1_d15","b1_d57"))

gex_umap[[col_donor]] = factor(gex_umap[[col_donor]], levels=donor_levels)

# the ordering of the points in a ggplot2 plot depends on 
# the ordering of the rows of the input data
# later rows are plotted later

# put $s_pos_clone TRUE after FALSE
# order() not affected by factor levels
# with order(), FALSE comes before TRUE
gex_umap = gex_umap[order(gex_umap[[col_s_pos_clone]]), ]

gex_umap[[col_s_pos_clone]] = factor(gex_umap[[col_s_pos_clone]],
                                     levels=c(TRUE, FALSE))

# visualization configs

vec_gg_anno_col = c("ABC"="mediumspringgreen",
                    "GC"="dodgerblue2",
                    "LNPC"="forestgreen",
                    "MBC"="plum2",
                    "Naive"="darkgoldenrod2",
                    "PB"="firebrick2",
                    "PB-like"="brown")

stopifnot(all(gex_umap[[col_anno]] %in% names(vec_gg_anno_col)))

umap_xlim = range(gex_umap[["umap_x"]]) * c(1.05, 1.05)
umap_ylim = range(gex_umap[["umap_y"]]) * c(1.05, 1.05)

g_size_s_pos = 1.25
```


#### Fig 2a - XBP1

```{r}
pb_gene_col = "ln_XBP1"
stopifnot(pb_gene_col %in% colnames(gex_umap))

# global scale
pb_gene_lim = range(gex_umap[[pb_gene_col]])

# 10x PB sort from blood
samples_tgx_pb = paste0("s", 87:93)

d="382-01"
    
cur_data = gex_umap[gex_umap[[col_donor]]==d &
                    gex_umap[[col_sample]] %in% samples_tgx_pb, ]
stopifnot(all(cur_data[[col_tp]]=="b1_d8"))
stopifnot(all(cur_data[[col_tissue]]=="blood"))

g = ggplot(data=cur_data,
           mapping=aes(x=umap_x, y=umap_y)) +
    geom_point(aes(color=!!sym(pb_gene_col)), 
               alpha=0.75, stroke=0, size=1) +
    scale_color_gradient(low="blue", high="red", limits=pb_gene_lim) +
    xlim(umap_xlim) +
    ylim(umap_ylim) +
    labs(color="XBP1") + 
    theme_bw() +
    theme(axis.title.x=element_blank(),   
          axis.text.x=element_blank(),    
          axis.ticks.x=element_blank()) + 
    theme(axis.title.y=element_blank(),   
          axis.text.y=element_blank(),    
          axis.ticks.y=element_blank()) + 
    theme(panel.grid.major=element_blank()) + 
    theme(panel.grid.minor=element_blank())  

fn = "fig_2a.png"
ggsave(filename=fn, plot=g, bg="transparent", 
       device="png", width=4, height=4, units="in")
rm(g)
```


#### Fig 2b - S+ PB

```{r}
g = ggplot(data=cur_data,
           mapping=aes(x=umap_x, y=umap_y)) +
    geom_point(aes(color=s_pos_clone, size=s_pos_clone), 
               alpha=0.7, stroke=0) +
    scale_color_manual(values=c("TRUE"="red", "FALSE"="gray")) +
    scale_size_manual(values=c("TRUE"=g_size_s_pos, "FALSE"=1)) +
    xlim(umap_xlim) +
    ylim(umap_ylim) +
    theme_bw() +
    theme(axis.title.x=element_blank(),   
          axis.text.x=element_blank(),    
          axis.ticks.x=element_blank()) + 
    theme(axis.title.y=element_blank(),   
          axis.text.y=element_blank(),    
          axis.ticks.y=element_blank()) + 
    theme(legend.position="none") + 
    theme(panel.grid.major=element_blank()) + 
    theme(panel.grid.minor=element_blank())  

fn = "fig_2b.png"
ggsave(filename=fn, plot=g, bg="transparent", 
       device="png", width=4, height=4, units="in")
rm(cur_data, g)
```


#### Fig 2e - LN

```{r}
cur_data = gex_umap[gex_umap[[col_donor]]==d &
                    gex_umap[[col_tissue]]=="LN", ]

### annotation

g = ggplot(data=cur_data,
           mapping=aes(x=umap_x, y=umap_y)) +
    geom_point(aes(color=anno_leiden_0.35), 
               alpha=0.75, stroke=0, size=1) +
    xlim(umap_xlim) +
    ylim(umap_ylim) +
    scale_color_manual(values=vec_gg_anno_col) +
    theme_bw() +
    theme(axis.title.x=element_blank(),   
          axis.text.x=element_blank(),    
          axis.ticks.x=element_blank()) + 
    theme(axis.title.y=element_blank(),   
          axis.text.y=element_blank(),    
          axis.ticks.y=element_blank()) + 
    theme(legend.position="none") + 
    theme(panel.grid.major=element_blank()) + 
    theme(panel.grid.minor=element_blank())  

fn = "fig_2e_annotation.png"
ggsave(filename=fn, plot=g, bg="transparent", 
       device="png", width=4, height=4, units="in")
rm(cur_data, g)


### S-specificity, by timepoint

for (tp in c("b1_d15", "b1_d57")) {
    
    cur_data = gex_umap[gex_umap[[col_donor]]==d &
                        gex_umap[[col_tissue]]=="LN" &
                        gex_umap[[col_tp]]==tp, ]
    
    g = ggplot(data=cur_data,
               mapping=aes(x=umap_x, y=umap_y)) +
        geom_point(aes(color=s_pos_clone, size=s_pos_clone), 
                   alpha=0.7, stroke=0) +
        scale_color_manual(values=c("TRUE"="red", "FALSE"="gray")) +
        scale_size_manual(values=c("TRUE"=g_size_s_pos, "FALSE"=1)) +
        xlim(umap_xlim) +
        ylim(umap_ylim) +
        theme_bw() +
        theme(axis.title.x=element_blank(),   
              axis.text.x=element_blank(),    
              axis.ticks.x=element_blank()) + 
        theme(axis.title.y=element_blank(),   
              axis.text.y=element_blank(),    
              axis.ticks.y=element_blank()) + 
        theme(legend.position="none") + 
        theme(panel.grid.major=element_blank()) + 
        theme(panel.grid.minor=element_blank())  
    
    fn = paste0("fig_2e_", tp, ".png")
    ggsave(filename=fn, plot=g, bg="transparent", 
           device="png", width=4, height=4, units="in")
    rm(cur_data, g)
}
```


#### Extended Data Fig 3g - annotation

```{r}
g = ggplot(data=gex_umap,
           mapping=aes(x=umap_x, y=umap_y)) +
    geom_point(aes(color=anno_leiden_0.35), 
               alpha=0.7, stroke=0, size=1) +
    scale_color_manual(values=vec_gg_anno_col) +
    facet_grid(donor~timepoint) +
    theme_bw() +
    theme(strip.background=element_rect(fill="transparent"),
          strip.text=element_text(size=13)) +
    theme(axis.title.x=element_blank(),   
          axis.text.x=element_blank(),    
          axis.ticks.x=element_blank()) + 
    theme(axis.title.y=element_blank(),   
          axis.text.y=element_blank(),    
          axis.ticks.y=element_blank()) + 
    theme(legend.position="none") + 
    theme(panel.grid.major=element_blank()) 

fn = "ed_fig_3g.png"
ggsave(filename=fn, plot=g, bg="transparent", 
       device="png", width=9, height=9, units="in")
rm(g)
```


#### Extended Data Fig 3h - S-specificity

```{r}
g = ggplot(data=gex_umap,
           mapping=aes(x=umap_x, y=umap_y)) +
    geom_point(aes(color=s_pos_clone, size=s_pos_clone), 
               alpha=0.7, stroke=0) +
    scale_color_manual(values=c("TRUE"="red", "FALSE"="gray")) +
    scale_size_manual(values=c("TRUE"=g_size_s_pos, "FALSE"=1)) +
    facet_grid(donor~timepoint) +
    theme_bw() +
    theme(strip.background=element_rect(fill="transparent"),
          strip.text=element_text(size=13)) +
    theme(axis.title.x=element_blank(),   
          axis.text.x=element_blank(),    
          axis.ticks.x=element_blank()) + 
    theme(axis.title.y=element_blank(),   
          axis.text.y=element_blank(),    
          axis.ticks.y=element_blank()) + 
    theme(legend.position="none") + 
    theme(panel.grid.major=element_blank())

fn = "ed_fig_3h.png"
ggsave(filename=fn, plot=g, bg="transparent", 
       device="png", width=9, height=9, units="in")
rm(g)
```

